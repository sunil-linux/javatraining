


One time step for adding dtd files to eclipse workspace:

1. Window->Preferences-> XML Catalog -> User specified entry -> Add
	Location: actual file system path
	Key: Value from config dtd file
	web address: value from config dtd file.

2. Same steps from 1 for mapping file.



Steps:

1. Add hibernate libraries along with db library to build path.
2. Prepare java object which maps to database table.
3. Prepare hibernate.cfg.xml file to src folder & udpate db configuration.
4. Prepare hibernate.hbm.xml & provide its mapping.
5. write Hibernate initilaization class which loads hibernate configuration & do its operation.



SessionFactory:
	Global object which provides configuraiton for your database, connections, sessions etc.

Hibernate:  
	Wrapper written on the top of existing jdbc code which simplifies database interaction.


Named Queries & Named Native Query:


Grouping queries related to single entity in the entity class.

Mostly they are defined on the top of the entity class.

@NamedQueries({
	@NamedQuery(name="",query=""),
	@NamedQuery(name="",query="")
})


@NamedNativeQueries({
	@NamedNativeQuery(name="",query="")
})


For better performance optimization for some of the queries at database level we can use sql queries with hibernate.




@Embeddable & @Embedded :

	Reuse the set of common object properties for mulitple entities in hibernate.


@EmbeddedId -> To create composite key from set of properties.





1) Using @ElementCollection
	** drop database & create new databse.


mysql> show tables;
+------------------+
| Tables_in_nobel  |
+------------------+
| Person_addresses |
| book             |
| person           |
| static_data      |
| static_dummy     |
| student          |
| studentdemo      |
| studentinfo      |
+------------------+
8 rows in set (0.00 sec)

mysql> select * from person;
+----+--------+-------+
| id | phone  | name  |
+----+--------+-------+
|  1 | 526262 | Komal |
+----+--------+-------+
1 row in set (0.00 sec)

mysql> select * from Person_addresses;
+-----------+---------+---------+-------------+
| Person_id | city    | pincode | street      |
+-----------+---------+---------+-------------+
|         1 | pune    |  413033 | dange chowk |
|         1 | Wagholi |  413032 | kharadi     |
+-----------+---------+---------+-------------+
2 rows in set (0.00 sec)

mysql> 






### After changing table & column names


mysql> select * from person;
+----+--------+-------+
| id | phone  | name  |
+----+--------+-------+
|  1 | 526262 | Komal |
+----+--------+-------+
1 row in set (0.00 sec)

mysql> select * from person_addresses;
+-----------+---------+---------+-------------+
| person_id | city    | pincode | street      |
+-----------+---------+---------+-------------+
|         1 | pune    |  413033 | dange chowk |
|         1 | Wagholi |  413032 | kharadi     |
+-----------+---------+---------+-------------+
2 rows in set (0.00 sec)

mysql> 






########## Relationships with Entities #################

1-1, 1-M, M-1, M-M

Unidirection ( person - vehicle )

Bidirection ( person-vehicle and vehicle-person)


#### One to One Mappin ##########



mysql> show tables;
+--------------------+
| Tables_in_hib_test |
+--------------------+
| person             |
| vehicle            |
+--------------------+
2 rows in set (0.00 sec)

mysql> select * from person;
+----+--------+-------+------------+
| id | phone  | name  | vehicle_id |
+----+--------+-------+------------+
|  1 | 526262 | Komal |          1 |
+----+--------+-------+------------+
1 row in set (0.00 sec)

mysql> select * from vehicle;
+----+---------+
| id | name    |
+----+---------+
|  1 | Jupiter |
+----+---------+
1 row in set (0.01 sec)

mysql> 


@OneToMany ->
	1 person can have mulitple vehicles

Separate table for maintaining relationship between 2 tables.(Primary keys of both tables )

And each entity will store their own info in new table.



mysql> select * from person;
+----+--------+-------+
| id | phone  | name  |
+----+--------+-------+
|  1 | 526262 | Komal |
+----+--------+-------+
1 row in set (0.00 sec)

mysql> select * from vehicle;
+----+---------+
| id | name    |
+----+---------+
|  1 | Jupiter |
|  2 | Activa  |
+----+---------+
2 rows in set (0.00 sec)

mysql> select * from person_vehicle;
+-----------+-------------+
| person_id | vehicles_id |
+-----------+-------------+
|         1 |           1 |
|         1 |           2 |
+-----------+-------------+
2 rows in set (0.00 sec)


3) @ManyToOne -> many vehicles belongs to single person.


Relationship maintained in separate table with both primary key as well as child table refer primary key from parent.


mysql> select * from person;
+----+--------+-------+
| id | phone  | name  |
+----+--------+-------+
|  1 | 526262 | Komal |
+----+--------+-------+
1 row in set (0.00 sec)

mysql> select * from vehicle;
+----+---------+-----------+
| id | name    | person_id |
+----+---------+-----------+
|  1 | Jupiter |         1 |
|  2 | Activa  |         1 |
+----+---------+-----------+
2 rows in set (0.00 sec)

mysql> select * from person_vehicle;
+-----------+-------------+
| person_id | vehicles_id |
+-----------+-------------+
|         1 |           1 |
|         1 |           2 |
+-----------+-------------+
2 rows in set (0.00 sec)




@OneToMany(mappedBy="vehicle") :-
List<Vehicle> vehicles;


 mappedBy signals hibernate that the key for the relationship is on the other side.

So no third table & vehicle table will maintain the mapping.

This means that although you link 2 tables together, only 1 of those tables has a foreign key constraint to the other one. MappedBy allows you to still link from the table not containing the 
constraint to the other table.

@ManyToMany -> 100% - 1%






































































	













	


























