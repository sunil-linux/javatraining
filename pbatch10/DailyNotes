Special cases for objects in java:

1) Object won't be created but ctr will call.

	a) Abstract class ( Only to derived class object )

2) Object will be created but ctr won't call.

	a) cloning
	b) serialization



(Object -> clone()(M)) -> Cloneable(I)


Why final methods or classes ?

	1) If you don't want to change the behaviour of the base classes by derived classes.

	2) Security.

		Ex: String class -> the behaviour of immutability should not be change.


What are final classes in java ?
	1) String
	2) Number ( Integer, Float, Double, Short )

All wrapper classes are final except Number.

final class Integer extends Number
{

}


Ctrl+Shift+T -> Open Type ( Search inside jar files as well )


Ctrl+Shift+R -> Open Resource ( Only specific to eclipse current workplace )


Ctrl+Shift+L -> For all eclipse shortcuts



Problem Statement:

	Gaming Application
	( Car, Bike, Truck )

Backend of gaming system:

	
interface:

This defines the contract between client and actual implementation object.

Which are the objects are controlled using remote ?

Bike









char - 1
char - 2 byte

SCP -> String



String are immutable.





21/10/2019

Abstraction:
	Hiding the implementation details and provide necessary details.
	Access specifier ( private, public )


Encapsulation:
	Binding of data and memmber functiont together

Switch switch = new PhonixSwitch();

//Abstraction - we just know 2 ways to interact with switch but don't know how they are going to function

switch.on();
switch.off();


interface Switch
{
	void on();
	void off();
}

class PheonixSwitch implements Switch
{
	private int wirelessSetting;
	private int current;

	public void on() {
		startWiring();
		startPassingCurrent();

		//internal logic
	}

	//internal complexicities and should be hide from outside ( client )
	public void startWiring() {

	}

	public void startPassingCurrent() {
	
	}

	public void off() {
		//internal logic
	}
}


Encapsulation:
	Binding of data and functions together in single unit(Class).


Stack:
	
	ArrayStack -> push,pop
		Using arrays

	LinkedStack -> push,pop
		using linkedlist




		***** Exception Handling:  **********

Exception:
	Runtime logical condition due to which the flow of an application can break.

Why exception handling:

1) To allow continue execution of application
2) To separate business logic from error handling.
	


try -> actual logic which might generate exception
catch -> exception handler based on type of exception
finally -> block which always executes irrespective of exception occured or not

Why finally ? what do you do in finally block ?

Mostly used for closing the resources like file, socket, database connection etc...



throw -> to throw exceptions manually to caller
throws -> It is used to bypass the exception handling to caller of the method. So current method is not responsible for handling exception.


try {

	//Business logic
	FILE *fp = fopne()
	int = fread()
	fclose();

}catch(Exception e) {
	//error handling
}


Types of Exception:

1) checked 
	
	
2) unchecked




Throwable -> it maintains the stack trace.




checked					unchecked

1. extends from Exception	1. extends from RuntimException

2. They are must to be handled  2. No need to handle at compile time
at compile tim by using 
try-catch or by rethrow to 
caller of the method.

3. Report error at compile time 3. No error at compile time but can
if not handled.			   generate runtime error.




What do you write in catch block ?

Mostly Log the exception details in file and rethrow to caller with given proper message..



Custom Exception / Business Exception:

InsufficientBalanceException
InvalidAccoutException


How to define custom exception:




		File Handling:



Operations:  R/W/A

File: It represents the file on file system.

	Deletion
	isDir / isFile
	size
	listOfDirectory content
	permissions( r/w/x)
	Creation of paths (Folders)


File: 
	Permanent storage


Text(Char)			Binary(Stream)


Reader/Writer			InputStream/OutputStream


FileReader | FileWriter		FileInputStream/FileOutputStream
BufferedReader | BufferedWriter	BIS | BOS
PipedReader |PipedWriter	PIS | POS


Byte / char



			FileInputStream | FileOutputStream -> Read 1 byte
			DataInputStream  | DataOutputStream -> Directly work with primitive types

			ObjectInputStream | ObjectOutputStream -> 
To work with any custom java object.



mkdir -> TO create single directly which is not exist
mkdirs -> Create nested directories.























































	














