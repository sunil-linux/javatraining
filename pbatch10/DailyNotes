Special cases for objects in java:

1) Object won't be created but ctr will call.

	a) Abstract class ( Only to derived class object )

2) Object will be created but ctr won't call.

	a) cloning
	b) serialization



(Object -> clone()(M)) -> Cloneable(I)


Why final methods or classes ?

	1) If you don't want to change the behaviour of the base classes by derived classes.

	2) Security.

		Ex: String class -> the behaviour of immutability should not be change.


What are final classes in java ?
	1) String
	2) Number ( Integer, Float, Double, Short )

All wrapper classes are final except Number.

final class Integer extends Number
{

}


Ctrl+Shift+T -> Open Type ( Search inside jar files as well )


Ctrl+Shift+R -> Open Resource ( Only specific to eclipse current workplace )


Ctrl+Shift+L -> For all eclipse shortcuts



Problem Statement:

	Gaming Application
	( Car, Bike, Truck )

Backend of gaming system:

	
interface:

This defines the contract between client and actual implementation object.

Which are the objects are controlled using remote ?

Bike









char - 1
char - 2 byte

SCP -> String



String are immutable.





21/10/2019

Abstraction:
	Hiding the implementation details and provide necessary details.
	Access specifier ( private, public )


Encapsulation:
	Binding of data and memmber functiont together

Switch switch = new PhonixSwitch();

//Abstraction - we just know 2 ways to interact with switch but don't know how they are going to function

switch.on();
switch.off();


interface Switch
{
	void on();
	void off();
}

class PheonixSwitch implements Switch
{
	private int wirelessSetting;
	private int current;

	public void on() {
		startWiring();
		startPassingCurrent();

		//internal logic
	}

	//internal complexicities and should be hide from outside ( client )
	public void startWiring() {

	}

	public void startPassingCurrent() {
	
	}

	public void off() {
		//internal logic
	}
}


Encapsulation:
	Binding of data and functions together in single unit(Class).


Stack:
	
	ArrayStack -> push,pop
		Using arrays

	LinkedStack -> push,pop
		using linkedlist




		***** Exception Handling:  **********

Exception:
	Runtime logical condition due to which the flow of an application can break.

Why exception handling:

1) To allow continue execution of application
2) To separate business logic from error handling.
	


try -> actual logic which might generate exception
catch -> exception handler based on type of exception
finally -> block which always executes irrespective of exception occured or not

Why finally ? what do you do in finally block ?

Mostly used for closing the resources like file, socket, database connection etc...



throw -> to throw exceptions manually to caller
throws -> It is used to bypass the exception handling to caller of the method. So current method is not responsible for handling exception.


try {

	//Business logic
	FILE *fp = fopne()
	int = fread()
	fclose();

}catch(Exception e) {
	//error handling
}


Types of Exception:

1) checked 
	
	
2) unchecked




Throwable -> it maintains the stack trace.




checked					unchecked

1. extends from Exception	1. extends from RuntimException

2. They are must to be handled  2. No need to handle at compile time
at compile tim by using 
try-catch or by rethrow to 
caller of the method.

3. Report error at compile time 3. No error at compile time but can
if not handled.			   generate runtime error.




What do you write in catch block ?

Mostly Log the exception details in file and rethrow to caller with given proper message..



Custom Exception / Business Exception:

InsufficientBalanceException
InvalidAccoutException


How to define custom exception:




		File Handling:



Operations:  R/W/A

File: It represents the file on file system.

	Deletion
	isDir / isFile
	size
	listOfDirectory content
	permissions( r/w/x)
	Creation of paths (Folders)


File: 
	Permanent storage


Text(Char)			Binary(Stream)


Reader/Writer			InputStream/OutputStream


FileReader | FileWriter		FileInputStream/FileOutputStream
BufferedReader | BufferedWriter	BIS | BOS
PipedReader |PipedWriter	PIS | POS


Byte / char



			FileInputStream | FileOutputStream -> Read 1 byte
			DataInputStream  | DataOutputStream -> Directly work with primitive types

			ObjectInputStream | ObjectOutputStream -> 
To work with any custom java object.



mkdir -> TO create single directly which is not exist
mkdirs -> Create nested directories.


End of file indicator:

char by char(int) read -> -1 | EOF 
line by line -> String -> null









Java 1.7

AutoCloseable Resources / try-with-resources



Closeable / AutoCloseable

All resources must implement this interface to be automatically closed.


try(
	FileReader fr = new FileReader("file");
	FileWriter fw = new FileWriter("");
) 

{
	//Actual logic of file operation	

}catch() {}




OIS / OOS -> Custom java object


FileInputStream fis = new FileInputStream("file")
ObjectInputStream ois = new ObjectInputStream(fis);




Serializable -> Which tells to jvm that i want to serialize this perticular object.

This must be implemented by object which is used for file/network/db storage.


Object -> 
	1. file
	2. network
	3. database save



Blank/Tagger/Marker Interfaces:

	The interface which don't have any methods declared inside.

They are used as meta information(or mark something) given to JVM or runtime system.







1. Serializable
2. Cloneable -> Deep copy- duplicate copy of same object
3. Remote -> RMI/RPC - Remote procedure call.


html tags:

	<b>My name is Sunil</b>




Serializable -> Bydefault serialization/deserialization is provided using jvm.


Serializable -> Inbuidl ser/deser ( Blank interface)
 
Externalizable -> custom ser/deser ( readObject, writeObject)


Custom Serialization -> Externalizable





Object				bytestream(file/socket/db)


bytestream(f/db/socket)		Object




			Nested Classes	



Functional Interface:
	Single method in interface.
	
For lambda expression we need FI. -> Java 8 feature ( 13 )

Java 2, 5, 8, 11 :

Tagger/Blank/Marker Interface: 
	No methods inside interface






java.util -> Basic collection classes

java 1.5 
java.util.concurrent ->  ConcurrentMap, BlockingQueue

	

Map -> Keys ( String, Integer )


String(All wrapper classes) -> Immutable class


Object -> Can store any type of data


Object data = "3o";

String str = "1p";

Integer.parseInt(str);

int pData = (int)data;
pData++;	;



	Generics / Template Programming

Adv:
	Compile time type safety by ensuring only specific type of data will be accepted for any type of object.


List<Integer>  list = new ArrayList();

List<Integer>  list = new ArrayList<>();

List<Integer>  list = new ArrayList<Integer>();


Serialization:
	Object to bytestream

Ser ->	Student(id=10, name="sunil", age=25)   -> file store

	transient int age; //Won't convert into bytestream


DeSer -> file store(bytestream) -> Student(id=10, name="sunil")(object)



Generics doesn't support primitive types while defining object.



List<int>  -> Not allowed ( float, double, char )

List<Integer> -> Allowed ( Float, Double, Character )





Assigment:



Employee(id, name, location, salary,managerName)  

EmployeeService -> 

CRUD  ( Add, Get all, Delete by ID )

1. Get employees whose salary is greater than given value ( 50,000)
2. Employess whos salary between given range ( 40K - 70K)
3. Employee based on given location
4. Update salary of all employees by 10% whose location is Pune.


5. Employees whose manager's salary is greater than given value.



1,Sunil,Pune,50000,Anil
2,Anil,Mumbai,70000,Satish
3,Satish,Pune,90000,Anand
4,Anand,Pune,100000,Arvind






Book(10,"SCJP","kathy")  -> 100

Book(10,"Java","kathy") -> 100




same name different paramets -> overloading

same name, same parameters, same signature -> Different class + Diff logic


Function overriding:

	Signature Same but different class having diff implementation of same method.



this -> this is a pointer which always points to the current object on which current method has been called.



hashCode -> The default implementation in Object class hashCode returns the object address.


Map<Key,Value>  -> 

put -> key.hashCode()

Map<Book,String>

*** 
Whenever you want to use any custom java class as the Key in Map like data structure ( HashMap,Hashtable etc..) you need to override hashCode & equals() method. ***


While overriding equals() & hashCode() both should consider same 
properties of the object.



****** Contract Between hashCode() & equals() *************

1. If  2 object are equal by equals() method then they must generate same hashCode.

"Karishma".equals("Karishma") -> true   => hashCode == 100


2. If 2 objects has same hashCode they may or may not be equal by equals() method.

Karishma == Ganesh   => 100

"karishma".equals("Ganesh") - > true / false









Properties -> File based key/value pairs in string format.


Why Not use Date ?
1. Not Immutable ( setter )
2. Not Thread safety



1) Without Zone information.

	a) LocalDate 
	b) LocalTime 
	c) LocalDateTime
	
2) With Zone information. 

	ZoneId ( region specific zone information)

	ZonedDate
	ZonedTime
	ZonedDateTime


		2019-12-03T11:40:44.341

DateTimeFormat: yyyy-mm-ddTHH:mm:ss.zzz



Concrete Class: Object can be instantiated.

Abstract class: Object can't be instantiated.

Singleton class: Only single object can be instantiated.
	


Garbage Collector : 
  It's background thread running continiously to verify/recycle the memory which is not getting used by object for the purpse of reuse.

runtime.gc()  / System.gc()  -> Run the garbage collector manually.



			Threading:

Thread[main,5,main]



Types of threads:

Worker Thread				Daemon Thread

1) Default created thread is worker	1) Thread t = new Thread();
  thread.				   t.setDaemon(true);
				
					You have manully call 					method for creating daemon thread.


2) JVM will wait till complete 		2) No wait.
execution of thread


3) Foreground task 			3) background task



			JoinAccount(5000)

p1						p2


Synchronization:

	Control multiple threads for accessing common shared object using lock concept.

Why Sync?
1. To avoid data inconsistency.
2. To avoid thread inteference.

How to apply sync ?

	1) synchronized(keyword) with method

	public synchronized void deposit(double amount) {
		//Logic which updates common shared prop
	}

	2) synchronized block

	public void deposit(double amount) {
			//multiple lines of code

			sychronized(this) {
				//Logic which updates common shared prop
			 //critical section of code
			}

			//normal code
	}

		

Types of locks:

1) Object level lock ( non-static props(method+var) )

2) Class level lock ( static props(method+var) )


Disadv:

1) Performance will impact due to locking object at operating system level ( monitors ).




Thread Communication:
	

join() method -> wait till complete execution of previous thread.	


-- Especially used in Asychronous Messaging System ------


JMS(Java Messaging System) / Kafka Queue -> Asychrounous communication between your components


BlockingQueue<Job> blockingQueue = new LinkedBlockingDeque<>(5);

--Add into queue
blockingQueue.put() -> sync

--Remove from queue
blockingQueue.take() -> sync




Runnable -> run() => we can't return value from thread. because run() method return type is void.


Callable -> call() => We can return value from thread.


ExecutorService Framework :
	You can create thread pools and he can manage the lifecycle of the thread.

Thread Pool : 

It is set of fixed threads created which can be utilized for different user tasks.


Future Object:
  It is used to read return value of the callable thread.


executorService.shutdown(); -> Stop accepting new tasks and wait till complete execution of pending tasks.

shutdownNow(); -> try to destroy everything but can't be gurantee. If there any tasks which still pending to execute it will return those tasks.




volatile keyword:

1. Only to be used with variables and not with methods or class.
2. It's used for alternative to synchronization.
3. It provides thread safety for object data members which obj shared with multiple threads.
4. Always data will be read from main memory rather than cpu locally cached data.
5. It prevents the compiler from the reordering of code.




Volatile Keyword	Synchronization Keyword
Volatile keyword is a field modifier.	Synchronized keyword modifies code blocks and methods.
The thread cannot be blocked for waiting in case of volatile.	Threads can be blocked for waiting in case of synchronized.
It improves thread performance.	Synchronized methods degrade the thread performance.
It synchronizes the value of one variable at a time between thread memory and main memory.	It synchronizes the value of all variables between thread memory and main memory.
Volatile fields are not subject to compiler optimization.	Synchronize is subject to compiler optimization.







class MyClass
{
	static int data = 10;
}

sychronized(joinAccount) {
	joinAccount.wait();
		
		deposit();

	joinAccount.notify();
}



Problem Statement :


Best flat finder:



Enum: 
	It groups similar elements for single type.

enum Color {YELLOW,RED,WHITE};



com.nobel.ff

domain 
company
productName

util
service
controller


Eclipse -> Free
IntelliJ Idea -> Free + Paid
Netbeans > For GUI development ( Windows/Dialog )




**********		JDBC 		**************



MongoDB -> NoSQL databases
	Store in JSON format.


Oracle / mySQL/ PLSQL/ DB2 / SQL server  -> 

MS-ACCESS / SQL Server:


Driver:

	Java		Driver		DB	


What are the interfaces? 

1. Connection
2. DriverManager
3. Statement / PreparedStatement / CallableStatement(call the proc)
4. ResultSet
5. DatabaseMetaData / ResultSetMetaData -> Data about database like which are tables, procedures, table info etc.

student -> columns, types,

select * from student;


Jar files -> Java Archieve

	It contains set of .class files with packages and some required configuration files ( .xml, .properties ) etc.


Type 4 Driver - Thin driver / Database Protocol Driver / 100% Java driver

It is faster than any other driver as well as portable.

Every database vendor provides this driver.


Problem statement:

	Read student data from mysql database table.


Username: sunil
Password: sunil@123
DB Name: nobel
Table Name: sunil


$ sudo mysql -u root -p
Enter password: root

$ create database nobelit;

$ use nobelit;

$ show tables; -> show tables present in nobelit.

$ create table student(id int primary key, name varchar(20), height float);

$ insert into student values(1,'sunil',6.1);


$ select * from student;

--- Display student table data -----



Steps to Connect to any Database from JDBC:


MySQL: server version: 5.7.28-0ubuntu0.18.04.4 

driver: com.mysql.jdbc.Driver / com.mysql.cj.jdbc.Driver
url: jdbc:mysql://<servername>:<port>/<dbname>

	 jdbc:mysql://localhost:3306/nobel

username: sunil / root
password: sunil@123 / your password



Oracle:
driver: oracle.jdbc.driver.OracleDriver 
url: jdbc:oracle:thin:@<machineip>:<port>:<servicename>

	jdbc:oracle:thin:@localhost:1521:xe

username: system
password: system 

1	sunil	90897965
2	Mandal	902692
4	Komal	82906


Add User to mysql if in case new mysql version not allow to access for root user & grant previledges.



$ CREATE USER 'newuser'@'localhost' IDENTIFIED BY 'user_password'

$ GRANT ALL PRIVILEGES ON *.* TO 'newuser'@'localhost';


Insert/Update/Delete  -> executeUpdate
select  -> executeQuery

mysql> delete from student where id=4;




---------------------------------------------------

*** Design Patterns ****

	X -> p1 -> problem 1 -> sol
	  -> p2 -> problem 2 -> sol
	
	Y -> p1 -> problem 1 -> sol

Some set of commmon problems in industry with similar patterns while architecting or solving technical issues which leads to have design patterns which will applied using some common guildlines or techniques.


Resources:
	File, Database Connection, Registry, Socket COnnection etcc......


Singleton design pattern:
	Only one object of class.

Proxy design patterns:

Observable design pattern:
	publish-subcribe


3 types of design patterns:

1) Creational 
	singleton, builder, factory, prototype

2) Structural 
	proxy, adapter,facade, decorator
	
3) Behaviour
	Strategy, Observable, Command, Chain of responsibilty

		

		(proxy)
user1	-> -> -> | 	facebook
	 <-	 |	youtube


	(proxy)
client  ->  |   target object



Guildlines:

1) Define private Constructor
2) static getInstance() method which returns the actual object
3) static reference to your class itself.


select * from student where id=?


SQL injection:
	

---------------------------------------------------------------


Bulk Insertion of data:


	

------------------ Hibernate ----------------

Advantage of hibernate:

  1) overcome the disAdv of jdbc with hibernate 
	a. Connection pooling
	b. Mapping file / annotation based mappers
	c. Removed boilterplate code

  2) Support for inheritance + relationship(1-M,M-1,M-M)
  3) Caching Support (1st & 2nd level cache)
  4) Fast Searching across different tables
  5) Automatic schema(tables) creation.
  6) Without writing queries data can be updated/saved.
  7) Support for HQL queries ( Java Object level queries )
  8) Data validation before insertion using validator framework
	


@Size(max=15, min=6)
private String username;


username:  min 6 & max 15
sunil@gmail.com, 825829682


XML -> Extensible Markup Language


Data Exchange:

Flipkart					HDFC
						
<acno>444</acno>
<name>SunilPatil</name>
<phone>4567892</phone>
<cardType>Credit</cardType>
<amount>1125</amount>



		HTML				XML
	Predefined Tags			Write your tags	

	<b><font><i><p>			
				<accountNo><phone><cvv>

	Representation			Data Exchange




<b><i>This is sunil</i></b>



Basic rules:
	1) <acno> </acno>
	2) <?xml version='1.0'>
	3) <acno>  </Acno>
	4) spl characters are nto allowed



1) Well formed XML
	Any xml which follows basic rules of xml 

2) Valid XML
	Well formed XML + Also need to follow rules defined by DTD/XML Schema files.


DTD/X-Schemas:
	Rules of orderning of data, frequency of data or option parameters etc...

DTD: Document Type Defination

(.dtd or .x... )


Hibernate is lightweight framwork which some set of required jar files to work with databases.

	1) Console
	2) Web
	3) GUI based


PreRequisites:

1) Core Java
2) Hibernate Jars
3) Configuration & Mapping file ( Optional: We can use Annotation )



hibernate.org


----------------- Maven ---------------

Maven Repository:
	Collections of different set of jar files from different organization.


<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.2.2.RELEASE</version>
</dependency>


1) Installation & with path setup
2) How to work with maven ?





Steps for hibernate application:


Step1: One time setup.

1. Add configuration & mapping file in eclipse.

	Window -> Preferences -> Search( XML Catlog ) -> user specified entry -> 

	Add entry for mapping & config file with File system path + Key + URL.


2) Create Java Project & Add required hibernate jars to build path including mysql connector jar.

3) Prepare Java Object which will map to database table.

4) Prepare mapping xml file(src folder) based on hibernate mapping dtd for map object to table.

5) Prepare hibernate configuration file based on hibernate dtd.
	(driver,url,uname,pwd, ddl, location of mapping file etccc)

	SessionFactory
	
	dialect -> convertion between java data types to database data types.
	
	hbm2ddl -> create/validate


validate: validate the schema, makes no changes to the database.
update: update the schema.
create: creates the schema, destroying previous data.
create-drop: drop the schema when the SessionFactory is closed explicitly, typically when the application is stopped.


6) Write hibernate loading class for sessionFactory creation & Start performing your operation.



update student set contact='528952' where id=1;



Retrieve single object using unique id from database using session:



load					get

1.ObjectNotFoundException		Return null object if given 						identifier obj not found
if given id object not found.
















